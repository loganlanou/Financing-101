// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trades.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const insertCongressTrade = `-- name: InsertCongressTrade :exec
INSERT INTO congress_trades (
    id, member, party, chamber, symbol, action, amount, executed_at, disclosure_date, sentiment, source_url
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    member=excluded.member,
    party=excluded.party,
    chamber=excluded.chamber,
    symbol=excluded.symbol,
    action=excluded.action,
    amount=excluded.amount,
    executed_at=excluded.executed_at,
    disclosure_date=excluded.disclosure_date,
    sentiment=excluded.sentiment,
    source_url=excluded.source_url
`

type InsertCongressTradeParams struct {
	ID             string
	Member         string
	Party          sql.NullString
	Chamber        sql.NullString
	Symbol         string
	Action         string
	Amount         sql.NullString
	ExecutedAt     time.Time
	DisclosureDate time.Time
	Sentiment      float64
	SourceUrl      sql.NullString
}

func (q *Queries) InsertCongressTrade(ctx context.Context, arg InsertCongressTradeParams) error {
	_, err := q.db.ExecContext(ctx, insertCongressTrade,
		arg.ID,
		arg.Member,
		arg.Party,
		arg.Chamber,
		arg.Symbol,
		arg.Action,
		arg.Amount,
		arg.ExecutedAt,
		arg.DisclosureDate,
		arg.Sentiment,
		arg.SourceUrl,
	)
	return err
}

const listRecentTrades = `-- name: ListRecentTrades :many
SELECT id, member, party, chamber, symbol, action, amount, executed_at, disclosure_date, sentiment, source_url
FROM congress_trades
ORDER BY executed_at DESC
LIMIT ?1
`

func (q *Queries) ListRecentTrades(ctx context.Context, limit int64) ([]CongressTrade, error) {
	rows, err := q.db.QueryContext(ctx, listRecentTrades, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CongressTrade
	for rows.Next() {
		var i CongressTrade
		if err := rows.Scan(
			&i.ID,
			&i.Member,
			&i.Party,
			&i.Chamber,
			&i.Symbol,
			&i.Action,
			&i.Amount,
			&i.ExecutedAt,
			&i.DisclosureDate,
			&i.Sentiment,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
